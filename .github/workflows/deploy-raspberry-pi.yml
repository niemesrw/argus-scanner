name: Deploy to Raspberry Pi

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'development'
        type: choice
        options:
          - development
          - testing
          - production
      force_rebuild:
        description: 'Force rebuild Docker image'
        required: false
        default: false
        type: boolean
      enable_real_scanning:
        description: 'Enable real network scanning (CAUTION)'
        required: false
        default: false
        type: boolean
  push:
    branches: [ main ]
    paths:
      - 'src/**'
      - 'docker/**'
      - 'requirements*.txt'

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  deploy-to-pi:
    name: Deploy to Raspberry Pi
    runs-on: self-hosted  # This will use your Pi runner
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Set deployment variables
      id: vars
      run: |
        # Set environment-specific variables
        ENV="${{ github.event.inputs.environment || 'development' }}"
        echo "environment=$ENV" >> $GITHUB_OUTPUT
        
        # Set mock mode based on environment and user input
        if [ "$ENV" == "production" ] && [ "${{ github.event.inputs.enable_real_scanning }}" == "true" ]; then
          echo "mock_mode=false" >> $GITHUB_OUTPUT
          echo "‚ö†Ô∏è WARNING: Real network scanning ENABLED for production"
        else
          echo "mock_mode=true" >> $GITHUB_OUTPUT
          echo "‚úÖ Mock mode enabled for safe testing"
        fi
        
        # Set container name
        echo "container_name=argus-scanner-$ENV" >> $GITHUB_OUTPUT
        
        # Set port based on environment
        case $ENV in
          "production") echo "port=8080" >> $GITHUB_OUTPUT ;;
          "testing") echo "port=8081" >> $GITHUB_OUTPUT ;;
          *) echo "port=8082" >> $GITHUB_OUTPUT ;;
        esac
    
    - name: Stop existing container
      run: |
        CONTAINER_NAME="${{ steps.vars.outputs.container_name }}"
        if docker ps -a --format "table {{.Names}}" | grep -q "^$CONTAINER_NAME$"; then
          echo "Stopping existing container: $CONTAINER_NAME"
          docker stop $CONTAINER_NAME || true
          docker rm $CONTAINER_NAME || true
        else
          echo "No existing container found: $CONTAINER_NAME"
        fi
    
    - name: Build Docker image locally
      if: ${{ github.event.inputs.force_rebuild == 'true' || github.event_name == 'push' }}
      run: |
        echo "Building Docker image locally on Raspberry Pi..."
        docker build -f docker/Dockerfile -t argus-scanner:latest .
        
        # Tag with environment
        docker tag argus-scanner:latest argus-scanner:${{ steps.vars.outputs.environment }}
    
    - name: Pull latest image (if not rebuilding)
      if: ${{ github.event.inputs.force_rebuild != 'true' && github.event_name != 'push' }}
      run: |
        echo "Pulling latest image from registry..."
        docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:main || {
          echo "Failed to pull from registry, building locally..."
          docker build -f docker/Dockerfile -t argus-scanner:latest .
        }
    
    - name: Create data directory
      run: |
        DATA_DIR="/home/pi/argus-data-${{ steps.vars.outputs.environment }}"
        mkdir -p "$DATA_DIR/logs" "$DATA_DIR/database"
        
        # Set proper permissions
        sudo chown -R 1000:1000 "$DATA_DIR"
        echo "Created data directory: $DATA_DIR"
    
    - name: Deploy container
      run: |
        CONTAINER_NAME="${{ steps.vars.outputs.container_name }}"
        PORT="${{ steps.vars.outputs.port }}"
        ENV="${{ steps.vars.outputs.environment }}"
        MOCK_MODE="${{ steps.vars.outputs.mock_mode }}"
        DATA_DIR="/home/pi/argus-data-$ENV"
        
        echo "Deploying container: $CONTAINER_NAME"
        echo "Environment: $ENV"
        echo "Port: $PORT"
        echo "Mock Mode: $MOCK_MODE"
        echo "Data Directory: $DATA_DIR"
        
        docker run -d \
          --name $CONTAINER_NAME \
          --restart unless-stopped \
          -p $PORT:8080 \
          -v "$DATA_DIR:/app/data" \
          -e ARGUS_ENV=$ENV \
          -e ARGUS_MOCK_MODE=$MOCK_MODE \
          -e ARGUS_WEB_PORT=8080 \
          -e ARGUS_LOG_LEVEL=INFO \
          -e ARGUS_SCAN_INTERVAL=300 \
          -e ARGUS_NETWORK_RANGE="192.168.1.0/24" \
          argus-scanner:latest
    
    - name: Wait for container startup
      run: |
        CONTAINER_NAME="${{ steps.vars.outputs.container_name }}"
        PORT="${{ steps.vars.outputs.port }}"
        
        echo "Waiting for container to start..."
        sleep 20
        
        # Check container status
        if docker ps --filter "name=$CONTAINER_NAME" --filter "status=running" | grep -q $CONTAINER_NAME; then
          echo "‚úÖ Container is running"
        else
          echo "‚ùå Container failed to start"
          docker logs $CONTAINER_NAME
          exit 1
        fi
        
        # Health check
        echo "Performing health check..."
        for i in {1..6}; do
          if curl -f http://localhost:$PORT/health; then
            echo "‚úÖ Health check passed"
            break
          else
            echo "‚è≥ Health check attempt $i/6 failed, waiting..."
            sleep 10
          fi
          
          if [ $i -eq 6 ]; then
            echo "‚ùå Health check failed after 6 attempts"
            docker logs $CONTAINER_NAME
            exit 1
          fi
        done
    
    - name: Display deployment info
      run: |
        CONTAINER_NAME="${{ steps.vars.outputs.container_name }}"
        PORT="${{ steps.vars.outputs.port }}"
        ENV="${{ steps.vars.outputs.environment }}"
        
        echo "üéâ Deployment completed successfully!"
        echo ""
        echo "üìä Deployment Summary:"
        echo "  Environment: $ENV"
        echo "  Container: $CONTAINER_NAME"
        echo "  Port: $PORT"
        echo "  Mock Mode: ${{ steps.vars.outputs.mock_mode }}"
        echo ""
        echo "üåê Access URLs:"
        echo "  Dashboard: http://$(hostname -I | awk '{print $1}'):$PORT"
        echo "  Health: http://$(hostname -I | awk '{print $1}'):$PORT/health"
        echo "  API: http://$(hostname -I | awk '{print $1}'):$PORT/api"
        echo ""
        echo "üê≥ Container Status:"
        docker ps --filter "name=$CONTAINER_NAME" --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
        echo ""
        echo "üìù Recent Logs:"
        docker logs --tail 20 $CONTAINER_NAME
    
    - name: Run post-deployment tests
      run: |
        PORT="${{ steps.vars.outputs.port }}"
        
        echo "üß™ Running post-deployment tests..."
        
        # Test API endpoints
        echo "Testing API endpoints..."
        curl -f http://localhost:$PORT/api/devices || echo "‚ùå Devices API failed"
        curl -f http://localhost:$PORT/api/stats || echo "‚ùå Stats API failed"
        
        # Test dashboard
        echo "Testing dashboard..."
        curl -f http://localhost:$PORT/ || echo "‚ùå Dashboard failed"
        
        echo "‚úÖ Post-deployment tests completed"

  cleanup-old-containers:
    name: Cleanup Old Containers
    runs-on: self-hosted
    needs: deploy-to-pi
    if: always()
    
    steps:
    - name: Clean up old containers and images
      run: |
        echo "üßπ Cleaning up old containers and images..."
        
        # Remove stopped containers older than 1 day
        docker container prune -f --filter "until=24h"
        
        # Remove unused images older than 1 day  
        docker image prune -f --filter "until=24h"
        
        # Keep only latest 3 versions of argus-scanner images
        docker images argus-scanner --format "table {{.Repository}}:{{.Tag}}\t{{.CreatedAt}}" | \
          tail -n +4 | head -n -3 | awk '{print $1}' | \
          xargs -r docker rmi || true
        
        echo "‚úÖ Cleanup completed"
        
        # Show current Docker usage
        echo "üìä Current Docker usage:"
        docker system df