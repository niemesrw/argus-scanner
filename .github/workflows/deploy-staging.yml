name: Deploy to Staging/Production

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production
      version:
        description: 'Version to deploy (leave empty for latest)'
        required: false
        type: string
  push:
    tags:
      - 'v*.*.*'

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # Pre-deployment checks
  pre-deploy-check:
    name: Pre-deployment Checks
    runs-on: ubuntu-latest
    outputs:
      deploy_version: ${{ steps.version.outputs.version }}
      
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Determine version
      id: version
      run: |
        if [ "${{ github.event_name }}" == "push" ] && [ "${{ startsWith(github.ref, 'refs/tags/v') }}" == "true" ]; then
          VERSION="${GITHUB_REF#refs/tags/}"
        elif [ -n "${{ github.event.inputs.version }}" ]; then
          VERSION="${{ github.event.inputs.version }}"
        else
          VERSION="main"
        fi
        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "Deploying version: $VERSION"
    
    - name: Check if image exists
      run: |
        docker manifest inspect ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.version.outputs.version }} || \
        (echo "Image not found!" && exit 1)
    
    - name: Run deployment readiness checks
      run: |
        echo "âœ“ Image exists"
        echo "âœ“ Version determined: ${{ steps.version.outputs.version }}"
        echo "âœ“ Target environment: ${{ github.event.inputs.environment || 'production' }}"

  # Deploy to staging
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: pre-deploy-check
    if: github.event.inputs.environment == 'staging' || (github.event_name == 'push' && contains(github.ref, '-rc'))
    environment:
      name: staging
      url: https://staging.argus-scanner.example.com
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Configure kubectl
      run: |
        echo "${{ secrets.STAGING_KUBECONFIG }}" | base64 -d > kubeconfig
        echo "KUBECONFIG=$(pwd)/kubeconfig" >> $GITHUB_ENV
    
    - name: Deploy to Kubernetes
      run: |
        # Create namespace if not exists
        kubectl create namespace argus-staging --dry-run=client -o yaml | kubectl apply -f -
        
        # Apply configurations
        kubectl apply -f k8s/staging/ -n argus-staging
        
        # Update image
        kubectl set image deployment/argus-scanner \
          argus=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.pre-deploy-check.outputs.deploy_version }} \
          -n argus-staging
        
        # Wait for rollout
        kubectl rollout status deployment/argus-scanner -n argus-staging --timeout=300s
    
    - name: Run smoke tests
      run: |
        # Wait for service to be ready
        sleep 30
        
        # Check health endpoint
        STAGING_URL=$(kubectl get ingress argus-scanner -n argus-staging -o jsonpath='{.spec.rules[0].host}')
        curl -f https://$STAGING_URL/health || exit 1
        
        # Run basic API tests
        python scripts/smoke_tests.py --url https://$STAGING_URL
    
    - name: Clean up
      if: always()
      run: rm -f kubeconfig

  # Deploy to production
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [pre-deploy-check, deploy-staging]
    if: |
      always() && 
      (needs.deploy-staging.result == 'success' || needs.deploy-staging.result == 'skipped') &&
      (github.event.inputs.environment == 'production' || (github.event_name == 'push' && startsWith(github.ref, 'refs/tags/v') && !contains(github.ref, '-')))
    environment:
      name: production
      url: https://argus-scanner.example.com
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Configure kubectl
      run: |
        echo "${{ secrets.PRODUCTION_KUBECONFIG }}" | base64 -d > kubeconfig
        echo "KUBECONFIG=$(pwd)/kubeconfig" >> $GITHUB_ENV
    
    - name: Backup current deployment
      run: |
        # Export current deployment
        kubectl get deployment argus-scanner -n argus-production -o yaml > backup-deployment.yaml || true
        
        # Get current image version for rollback
        CURRENT_IMAGE=$(kubectl get deployment argus-scanner -n argus-production -o jsonpath='{.spec.template.spec.containers[0].image}' || echo "none")
        echo "ROLLBACK_IMAGE=$CURRENT_IMAGE" >> $GITHUB_ENV
        echo "Current production image: $CURRENT_IMAGE"
    
    - name: Deploy to Production
      run: |
        # Create namespace if not exists
        kubectl create namespace argus-production --dry-run=client -o yaml | kubectl apply -f -
        
        # Apply configurations
        kubectl apply -f k8s/production/ -n argus-production
        
        # Update image with rolling update
        kubectl set image deployment/argus-scanner \
          argus=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.pre-deploy-check.outputs.deploy_version }} \
          -n argus-production \
          --record
        
        # Wait for rollout
        kubectl rollout status deployment/argus-scanner -n argus-production --timeout=600s
    
    - name: Verify deployment
      id: verify
      run: |
        # Wait for service to stabilize
        sleep 60
        
        # Check health endpoint
        PROD_URL=$(kubectl get ingress argus-scanner -n argus-production -o jsonpath='{.spec.rules[0].host}')
        
        # Multiple health checks
        for i in {1..5}; do
          if curl -f https://$PROD_URL/health; then
            echo "Health check $i passed"
          else
            echo "Health check $i failed"
            exit 1
          fi
          sleep 10
        done
        
        # Check metrics
        curl -f https://$PROD_URL/metrics || true
    
    - name: Rollback on failure
      if: failure() && steps.verify.outcome == 'failure'
      run: |
        echo "Deployment verification failed, rolling back..."
        
        if [ "$ROLLBACK_IMAGE" != "none" ]; then
          kubectl set image deployment/argus-scanner \
            argus=$ROLLBACK_IMAGE \
            -n argus-production
          
          kubectl rollout status deployment/argus-scanner -n argus-production --timeout=300s
          echo "Rollback completed"
        else
          echo "No previous image to rollback to"
        fi
    
    - name: Clean up
      if: always()
      run: rm -f kubeconfig backup-deployment.yaml

  # Post-deployment tasks
  post-deploy:
    name: Post-deployment Tasks
    runs-on: ubuntu-latest
    needs: [deploy-staging, deploy-production]
    if: always() && (needs.deploy-staging.result == 'success' || needs.deploy-production.result == 'success')
    
    steps:
    - name: Send deployment notification
      env:
        SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK }}
      run: |
        ENVIRONMENT="${{ github.event.inputs.environment || 'production' }}"
        VERSION="${{ needs.pre-deploy-check.outputs.deploy_version }}"
        STATUS="success"
        COLOR="good"
        
        if [ "${{ needs.deploy-production.result }}" == "failure" ] || [ "${{ needs.deploy-staging.result }}" == "failure" ]; then
          STATUS="failed"
          COLOR="danger"
        fi
        
        curl -X POST $SLACK_WEBHOOK \
          -H 'Content-Type: application/json' \
          -d "{
            \"text\": \"Deployment to $ENVIRONMENT $STATUS\",
            \"attachments\": [{
              \"color\": \"$COLOR\",
              \"fields\": [
                {\"title\": \"Environment\", \"value\": \"$ENVIRONMENT\", \"short\": true},
                {\"title\": \"Version\", \"value\": \"$VERSION\", \"short\": true},
                {\"title\": \"Deployed by\", \"value\": \"${{ github.actor }}\", \"short\": true},
                {\"title\": \"Status\", \"value\": \"$STATUS\", \"short\": true}
              ]
            }]
          }"
    
    - name: Create deployment record
      uses: actions/github-script@v6
      with:
        script: |
          const environment = '${{ github.event.inputs.environment || 'production' }}';
          const version = '${{ needs.pre-deploy-check.outputs.deploy_version }}';
          
          // Create deployment
          const deployment = await github.rest.repos.createDeployment({
            owner: context.repo.owner,
            repo: context.repo.repo,
            ref: version,
            environment: environment,
            description: `Deploy ${version} to ${environment}`,
            auto_merge: false,
            required_contexts: []
          });
          
          // Create deployment status
          await github.rest.repos.createDeploymentStatus({
            owner: context.repo.owner,
            repo: context.repo.repo,
            deployment_id: deployment.data.id,
            state: 'success',
            environment_url: `https://${environment}.argus-scanner.example.com`,
            description: 'Deployment completed successfully'
          });
    
    - name: Update release notes
      if: github.event_name == 'push' && startsWith(github.ref, 'refs/tags/v')
      uses: actions/github-script@v6
      with:
        script: |
          const tag = context.ref.replace('refs/tags/', '');
          
          try {
            const release = await github.rest.repos.getReleaseByTag({
              owner: context.repo.owner,
              repo: context.repo.repo,
              tag: tag
            });
            
            // Update release with deployment info
            await github.rest.repos.updateRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              release_id: release.data.id,
              body: release.data.body + '\n\n### Deployment\n- âœ… Deployed to production\n- ðŸ“… ' + new Date().toISOString()
            });
          } catch (error) {
            console.log('No release found for tag:', tag);
          }