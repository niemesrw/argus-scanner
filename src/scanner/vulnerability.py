"""
Vulnerability scanning module
"""
import logging
import re
from typing import List, Dict, Optional, Tuple
from datetime import datetime
import nmap
import requests
from bs4 import BeautifulSoup

from src.database.models import (
    Device, Service, Vulnerability, Severity,
    get_db_session
)
from src.config.settings import Settings

logger = logging.getLogger(__name__)

class VulnerabilityScanner:
    """Handles vulnerability detection and CVE matching"""
    
    # Common vulnerable service versions
    KNOWN_VULNERABILITIES = {
        'openssh': {
            '7.2': ['CVE-2016-10009', 'CVE-2016-10010'],
            '7.4': ['CVE-2017-15906'],
            '7.7': ['CVE-2018-15473']
        },
        'apache': {
            '2.4.29': ['CVE-2018-1312', 'CVE-2018-1333'],
            '2.4.41': ['CVE-2020-1927', 'CVE-2020-1934']
        },
        'nginx': {
            '1.16.0': ['CVE-2019-9511', 'CVE-2019-9513'],
            '1.14.0': ['CVE-2018-16843', 'CVE-2018-16844']
        },
        'mysql': {
            '5.7.20': ['CVE-2018-2562', 'CVE-2018-2622'],
            '5.6.35': ['CVE-2017-3599', 'CVE-2017-3600']
        }
    }
    
    def __init__(self, settings: Settings):
        self.settings = settings
        self.nm = nmap.PortScanner()
        self.db = get_db_session(settings.db_path)
        self.cve_cache = {}
    
    def scan_device_vulnerabilities(self, device_id: int) -> List[Dict]:
        """Scan a device for vulnerabilities"""
        device = self.db.query(Device).filter_by(id=device_id).first()
        if not device:
            logger.error(f"Device with id {device_id} not found")
            return []
        
        logger.info(f"Scanning vulnerabilities for device: {device.ip_address}")
        
        vulnerabilities = []
        
        # Get all services for the device
        services = self.db.query(Service).filter_by(device_id=device_id).all()
        
        for service in services:
            # Check for version-based vulnerabilities
            version_vulns = self._check_version_vulnerabilities(service)
            vulnerabilities.extend(version_vulns)
            
            # Run vulnerability scripts if enabled
            if not self.settings.mock_mode:
                script_vulns = self._run_vulnerability_scripts(
                    device.ip_address, 
                    service.port, 
                    service.protocol
                )
                vulnerabilities.extend(script_vulns)
        
        # Save vulnerabilities to database
        self._save_vulnerabilities(vulnerabilities)
        
        # Update device risk score
        self._update_risk_score(device, vulnerabilities)
        
        return vulnerabilities
    
    def _check_version_vulnerabilities(self, service: Service) -> List[Dict]:
        """Check for known vulnerabilities based on service version"""
        vulnerabilities = []
        
        if not service.product or not service.version:
            return vulnerabilities
        
        product_lower = service.product.lower()
        
        # Check against known vulnerabilities
        for product_key, versions in self.KNOWN_VULNERABILITIES.items():
            if product_key in product_lower:
                for version, cves in versions.items():
                    if self._version_match(service.version, version):
                        for cve in cves:
                            vuln = self._create_vulnerability_dict(
                                service_id=service.id,
                                cve_id=cve,
                                name=f"{service.product} {service.version} vulnerability",
                                description=f"Known vulnerability in {service.product} version {service.version}"
                            )
                            vulnerabilities.append(vuln)
        
        return vulnerabilities
    
    def _run_vulnerability_scripts(self, ip: str, port: int, protocol: str) -> List[Dict]:
        """Run nmap vulnerability detection scripts"""
        vulnerabilities = []
        
        try:
            # Run common vulnerability scripts
            scripts = [
                'vuln',  # General vulnerability scan
                'ssl-heartbleed',  # Heartbleed
                'http-vuln-cve2017-5638',  # Apache Struts
                'smb-vuln-ms17-010',  # EternalBlue
                'ssl-poodle',  # POODLE
                'http-shellshock'  # Shellshock
            ]
            
            script_args = ','.join(scripts)
            
            self.nm.scan(
                hosts=ip,
                ports=str(port),
                arguments=f'-p {port} --script {script_args}'
            )
            
            if ip in self.nm.all_hosts() and protocol in self.nm[ip]:
                if port in self.nm[ip][protocol]:
                    port_info = self.nm[ip][protocol][port]
                    
                    # Parse script results
                    if 'script' in port_info:
                        for script_name, output in port_info['script'].items():
                            if 'VULNERABLE' in output.upper():
                                vuln = self._parse_script_vulnerability(
                                    script_name, output, port
                                )
                                if vuln:
                                    vulnerabilities.append(vuln)
            
        except Exception as e:
            logger.error(f"Error running vulnerability scripts: {e}")
        
        return vulnerabilities
    
    def _parse_script_vulnerability(self, script_name: str, output: str, port: int) -> Optional[Dict]:
        """Parse vulnerability information from nmap script output"""
        # Extract CVE IDs from output
        cve_pattern = r'CVE-\d{4}-\d{4,}'
        cves = re.findall(cve_pattern, output)
        
        # Determine severity based on script output
        severity = Severity.MEDIUM
        if 'CRITICAL' in output.upper():
            severity = Severity.CRITICAL
        elif 'HIGH' in output.upper():
            severity = Severity.HIGH
        
        # Get service from database
        service = self.db.query(Service).filter_by(port=port).first()
        if not service:
            return None
        
        return self._create_vulnerability_dict(
            service_id=service.id,
            cve_id=cves[0] if cves else None,
            name=f"Vulnerability detected by {script_name}",
            description=output[:500],  # Truncate long outputs
            severity=severity
        )
    
    def _create_vulnerability_dict(
        self,
        service_id: int,
        cve_id: Optional[str],
        name: str,
        description: str,
        severity: Severity = Severity.MEDIUM
    ) -> Dict:
        """Create vulnerability dictionary"""
        vuln_dict = {
            'service_id': service_id,
            'cve_id': cve_id,
            'name': name,
            'description': description,
            'severity': severity,
            'discovered_at': datetime.utcnow()
        }
        
        # Fetch additional CVE details if available
        if cve_id and self.settings.cve_api_key:
            cve_details = self._fetch_cve_details(cve_id)
            if cve_details:
                vuln_dict.update(cve_details)
        
        return vuln_dict
    
    def _fetch_cve_details(self, cve_id: str) -> Optional[Dict]:
        """Fetch CVE details from NVD or other sources"""
        if cve_id in self.cve_cache:
            return self.cve_cache[cve_id]
        
        try:
            # Use NVD API (requires API key for better rate limits)
            base_url = "https://services.nvd.nist.gov/rest/json/cves/2.0"
            params = {'cveId': cve_id}
            
            if self.settings.cve_api_key:
                headers = {'apiKey': self.settings.cve_api_key}
            else:
                headers = {}
            
            response = requests.get(base_url, params=params, headers=headers, timeout=10)
            
            if response.status_code == 200:
                data = response.json()
                if 'vulnerabilities' in data and data['vulnerabilities']:
                    cve_item = data['vulnerabilities'][0]['cve']
                    
                    details = {
                        'cvss_score': self._extract_cvss_score(cve_item),
                        'references': self._extract_references(cve_item),
                        'exploit_available': self._check_exploit_availability(cve_id)
                    }
                    
                    self.cve_cache[cve_id] = details
                    return details
            
        except Exception as e:
            logger.error(f"Error fetching CVE details for {cve_id}: {e}")
        
        return None
    
    def _extract_cvss_score(self, cve_item: Dict) -> Optional[float]:
        """Extract CVSS score from CVE data"""
        try:
            if 'metrics' in cve_item:
                if 'cvssMetricV31' in cve_item['metrics']:
                    return cve_item['metrics']['cvssMetricV31'][0]['cvssData']['baseScore']
                elif 'cvssMetricV30' in cve_item['metrics']:
                    return cve_item['metrics']['cvssMetricV30'][0]['cvssData']['baseScore']
                elif 'cvssMetricV2' in cve_item['metrics']:
                    return cve_item['metrics']['cvssMetricV2'][0]['cvssData']['baseScore']
        except:
            pass
        return None
    
    def _extract_references(self, cve_item: Dict) -> List[str]:
        """Extract reference URLs from CVE data"""
        references = []
        try:
            if 'references' in cve_item:
                for ref in cve_item['references']:
                    references.append(ref.get('url', ''))
        except:
            pass
        return references[:5]  # Limit to 5 references
    
    def _check_exploit_availability(self, cve_id: str) -> bool:
        """Check if exploit is available for CVE"""
        # In production, this would check exploit databases
        # For now, we'll use a simple heuristic
        year = int(cve_id.split('-')[1])
        return year < 2020  # Older CVEs more likely to have exploits
    
    def _version_match(self, installed: str, vulnerable: str) -> bool:
        """Check if installed version matches vulnerable version"""
        # Simple version matching - in production, use proper version comparison
        return installed.startswith(vulnerable)
    
    def _save_vulnerabilities(self, vulnerabilities: List[Dict]) -> None:
        """Save vulnerabilities to database"""
        for vuln_dict in vulnerabilities:
            try:
                # Check if vulnerability already exists
                existing = self.db.query(Vulnerability).filter_by(
                    service_id=vuln_dict['service_id'],
                    cve_id=vuln_dict.get('cve_id'),
                    name=vuln_dict['name']
                ).first()
                
                if not existing:
                    vulnerability = Vulnerability(**vuln_dict)
                    self.db.add(vulnerability)
                else:
                    # Update last checked time
                    existing.last_checked = datetime.utcnow()
                
                self.db.commit()
                
            except Exception as e:
                logger.error(f"Error saving vulnerability: {e}")
                self.db.rollback()
    
    def _update_risk_score(self, device: Device, vulnerabilities: List[Dict]) -> None:
        """Update device risk score based on vulnerabilities"""
        risk_score = 0.0
        
        severity_weights = {
            Severity.CRITICAL: 10.0,
            Severity.HIGH: 7.5,
            Severity.MEDIUM: 5.0,
            Severity.LOW: 2.5,
            Severity.INFO: 1.0
        }
        
        for vuln in vulnerabilities:
            severity = vuln.get('severity', Severity.MEDIUM)
            risk_score += severity_weights.get(severity, 5.0)
            
            # Add extra weight for exploitable vulnerabilities
            if vuln.get('exploit_available'):
                risk_score += 5.0
        
        # Normalize to 0-100 scale
        device.risk_score = min(risk_score, 100.0)
        
        try:
            self.db.commit()
        except Exception as e:
            logger.error(f"Error updating risk score: {e}")
            self.db.rollback()